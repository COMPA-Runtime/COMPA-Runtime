/**
 * @file main.cpp
 * @generated by class org.ietr.preesm.pimm.algorithm.SpiderMainFilePrinter
 * @date Fri Aug 24 11:31:30 CEST 2018
 *
 */

#include <spider.h>

#include <stdexcept>
#include <cstdio>
#include <cstdlib>
#include <algorithm>
#include <getopt.h>

#include "actors.h"
#include "dac_fft_group.h"

/* Include your files here */

#define SH_MEM_SIZE 0x01000000

int stopThreads;

void usage(){
	printf("Usage: \n");
	printf("\t<exe> [opts] \n");
	printf("\t\t -h : Print this message\n");
	printf("\t\t -n : NLrt (default 1)\n");
	printf("\t\t -m : MemAllocType [Dummy(default),Special]\n");
	printf("\t\t -s : SchedulerType [Lits(default)]\n");
	printf("\t\t -t : Enable Traces\n");
	printf("\t\t -o : Enable Graph optims\n");
}

int main(int argc, char* argv[]){
	SpiderConfig cfg;
	ExecutionStat stat;

	int NLrt = 1;
	MemAllocType memAllocType = MEMALLOC_DUMMY;
	SchedulerType schedulerType = SCHEDULER_LIST;
	bool traceEnabled = false;
	bool graphOptims = false;

	// Parse input args
	int c=0;
	std::string str;
	while ((c = getopt(argc, argv, "nmst:o:")) != -1)
	switch(c)
	{
		case 'n':
			NLrt = atoi(optarg);
			break;
		case 'm':
			str = optarg;
			std::transform(str.begin(), str.end(), str.begin(), ::tolower);
			if(str.compare("dummy") == 0)
				memAllocType = MEMALLOC_DUMMY;
			else if(str.compare("special") == 0)
				memAllocType = MEMALLOC_SPECIAL_ACTOR;
			else {
				printf("Error: MemAlloc %s not found \n", optarg);
				usage();
			}
			break;
		case 's':
			str = optarg;
			std::transform(str.begin(), str.end(), str.begin(), ::tolower);
			if(str.compare("list") == 0)
				schedulerType = SCHEDULER_LIST;
			else {
				printf("Error: Scheduler %s not found \n", optarg);
				usage();
			}
			break;
		case 't':
			traceEnabled = true;
			break;
		case 'o':
			graphOptims = true;
			break;
		case 'h':
			usage();
			break;
	}

	// Setting memory info
	cfg.memAllocType = memAllocType;
	cfg.memAllocStart = (void*)0;
	cfg.memAllocSize = SH_MEM_SIZE;

	// Setting scheduler
	cfg.schedulerType = schedulerType;

	// Declaring stacks
	cfg.archiStack.name = "ArchiStack";
	cfg.archiStack.type = STACK_DYNAMIC;

	cfg.lrtStack.name = "LrtStack";
	cfg.lrtStack.type = STACK_DYNAMIC;

	cfg.pisdfStack.name = "PiSDFStack";
	cfg.pisdfStack.type = STACK_DYNAMIC;

	cfg.srdagStack.name = "SrdagStack";
	cfg.srdagStack.type = STACK_DYNAMIC;

	cfg.transfoStack.name = "TransfoStack";
	cfg.transfoStack.type = STACK_DYNAMIC;

	// Setting desired number of LRT/thread
	cfg.platform.nLrt = NLrt;

	// Setting size of shared mem
	cfg.platform.shMemSize = SH_MEM_SIZE;

	// Setting graph PiSDF graph
	cfg.platform.fcts = dac_fft_group_fcts;
	cfg.platform.nLrtFcts = N_FCT_DAC_FFT_GROUP;

	cfg.traceEnabled = traceEnabled;
	cfg.useGraphOptim = graphOptims;

	cfg.verbose = false;
	
	// Papify instrumentation will not be used
	cfg.usePapify = false;

	try {
		// Spider initialisation
		Spider::init(cfg);
		
		// Actor initializations
		initActors();

		// PiSDF graph construction
		init_dac_fft_group(64*1024);

		printf("Start\n");

		// Compute the SR-DAG, scheduling and executing the main graph
		Spider::iterate();

		// Printing Gantt
		if (cfg.traceEnabled) {
			Spider::printGantt("gantt.pgantt", "gantt_tex.dat", &stat);
			Spider::printSRDAG("srdag.gv");
			printf("Total execution time: %lf ms\n",  (stat.execTime + stat.schedTime) / 1000000.);
			printf("Application execution time: %lf ms\n",  stat.execTime / 1000000.);
			printf("SPIDER overhead time: %lf ms\n",  stat.schedTime / 1000000.);
		}
		
		printf("finished\n");

		// PiSDF graph destruction
		free_dac_fft_group();

		Spider::clean();
		
		
		// Actor finalisation here if needed
		
	} catch(std::exception &e) {
		printf("Exception : %s\n", e.what());
	}

	return 0;
}


